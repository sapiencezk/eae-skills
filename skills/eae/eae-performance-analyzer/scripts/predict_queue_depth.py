#!/usr/bin/env python3
"""
Queue Depth Predictor for EcoStruxure Automation Expert Applications

Models event queue behavior, predicts peak depths under various load scenarios.

Exit Codes:
    0: Safe (<100 events)
   10: Moderate (100-500 events)
   11: Overflow risk (>500 events)
    1: Error (missing dependencies, invalid input)
"""

import argparse
import json
import sys
from dataclasses import dataclass, asdict, field
from pathlib import Path
from typing import List, Dict, Any, Optional


@dataclass
class ValidationResult:
    """Structured result for script outputs."""
    success: bool
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    details: Dict[str, Any] = field(default_factory=dict)

    @property
    def exit_code(self) -> int:
        """Calculate exit code based on queue depth predictions."""
        if not self.success:
            return 1

        queue_predictions = self.details.get("queue_predictions", {})
        if not queue_predictions:
            return 0

        max_queue_depth = 0
        for resource_data in queue_predictions.values():
            internal_queue = resource_data.get("internal_queue", {})
            worst_case = internal_queue.get("worst_case", 0)
            max_queue_depth = max(max_queue_depth, worst_case)

        if max_queue_depth >= 500:
            return 11  # Critical
        elif max_queue_depth >= 100:
            return 10  # Warning
        else:
            return 0  # Safe

    def to_json(self) -> str:
        return json.dumps(asdict(self), indent=2)


def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Predict event queue depths for EAE application"
    )
    parser.add_argument("--app-dir", required=True, help="Path to EAE application")
    parser.add_argument(
        "--event-flow-results",
        required=True,
        help="Path to JSON output from analyze_event_flow.py"
    )
    parser.add_argument("--resource", help="Specific resource (optional)")
    parser.add_argument("--output", help="JSON output path (default: stdout)")
    parser.add_argument(
        "--scenario",
        default="normal",
        choices=["normal", "burst", "worst-case"],
        help="Load scenario to simulate"
    )
    return parser.parse_args()


def load_event_flow_results(filepath: Path) -> Dict[str, Any]:
    """Load multiplication factors from analyze_event_flow.py output."""
    try:
        with open(filepath, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {"error": f"Event flow results not found: {filepath}"}
    except json.JSONDecodeError as e:
        return {"error": f"Invalid JSON in event flow results: {e}"}


def simulate_queue_depth(
    multiplication_factors: Dict[str, float],
    scenario: str
) -> Dict[str, Dict[str, int]]:
    """
    Simulate queue depth under different scenarios.
    Returns predicted queue depths per resource.
    """
    # Scenario multipliers
    scenario_factors = {
        "normal": 1.0,
        "burst": 2.0,
        "worst-case": 5.0
    }

    scenario_mult = scenario_factors[scenario]

    # Simplified simulation assumptions
    # In reality, would model I/O bus cycles, timer frequencies, etc.
    base_event_rate_hz = 20  # Assumed baseline: 20 events/sec from I/O
    processing_rate_hz = 100  # Can process 100 events/sec

    predictions = {}

    for source, mult_factor in multiplication_factors.items():
        # External queue: Events coming from outside
        external_rate = base_event_rate_hz * scenario_mult
        external_queue_depth = int(external_rate / 2)  # Simplified model

        # Internal queue: Events generated by cascade (multiplication)
        internal_rate = external_rate * mult_factor
        net_generation = internal_rate - processing_rate_hz

        if net_generation > 0:
            # Queue growing
            internal_queue_depth = int(net_generation * 2)  # 2 second accumulation
        else:
            # Queue draining
            internal_queue_depth = 0

        resource_name = f"Resource_{source.split('_')[0]}"

        if resource_name not in predictions:
            predictions[resource_name] = {
                "external_queue": 0,
                "internal_queue": 0
            }

        predictions[resource_name]["external_queue"] = max(
            predictions[resource_name]["external_queue"],
            external_queue_depth
        )
        predictions[resource_name]["internal_queue"] = max(
            predictions[resource_name]["internal_queue"],
            internal_queue_depth
        )

    return predictions


def predict_queue_depth(
    app_dir: Path,
    event_flow_results_path: Path,
    scenario: str,
    resource_filter: Optional[str]
) -> ValidationResult:
    """Main queue depth prediction function."""
    errors = []
    warnings = []

    # Load event flow results
    event_flow_data = load_event_flow_results(event_flow_results_path)

    if "error" in event_flow_data:
        return ValidationResult(
            success=False,
            errors=[event_flow_data["error"]],
            details={}
        )

    # Extract multiplication factors
    mult_factors = event_flow_data.get("details", {}).get("multiplication_factors", {})

    if not mult_factors:
        warnings.append("No multiplication factors found in event flow results")
        return ValidationResult(
            success=True,
            warnings=warnings,
            details={
                "queue_predictions": {},
                "event_sources_contribution": {},
                "recommendations": []
            }
        )

    print(f"Loaded {len(mult_factors)} multiplication factors", file=sys.stderr)

    # Run simulations for all scenarios
    scenarios = ["normal", "burst", "worst-case"]
    queue_predictions = {}

    for scen in scenarios:
        scenario_results = simulate_queue_depth(mult_factors, scen)

        for resource, queues in scenario_results.items():
            if resource not in queue_predictions:
                queue_predictions[resource] = {
                    "external_queue": {},
                    "internal_queue": {},
                    "overflow_risk": "UNKNOWN"
                }

            queue_predictions[resource]["external_queue"][scen.replace("-", "_")] = queues["external_queue"]
            queue_predictions[resource]["internal_queue"][scen.replace("-", "_")] = queues["internal_queue"]

    # Assess overflow risk
    for resource, data in queue_predictions.items():
        worst_case_internal = data["internal_queue"].get("worst_case", 0)

        if worst_case_internal > 1000:
            data["overflow_risk"] = "CRITICAL"
            data["recommendation"] = "Worst-case exceeds 1000 events. Reduce multiplication or add resources."
        elif worst_case_internal > 500:
            data["overflow_risk"] = "HIGH"
            data["recommendation"] = "High queue depth risk. Review event sources and consolidate."
        elif worst_case_internal > 100:
            data["overflow_risk"] = "MODERATE"
            data["recommendation"] = "Monitor queue depths under real load conditions."
        else:
            data["overflow_risk"] = "LOW"
            data["recommendation"] = "Queue depths within safe limits."

    # Event source contributions (simplified)
    event_sources_contribution = {
        "IO_CHANGE": "35%",
        "HMI_INTERACTION": "25%",
        "TIMERS": "20%",
        "CROSS_COMMUNICATION": "15%",
        "INTERNAL_LOGIC": "5%"
    }

    # Generate recommendations
    recommendations = []
    for resource, data in queue_predictions.items():
        if data["overflow_risk"] in ["CRITICAL", "HIGH"]:
            recommendations.append(data["recommendation"])

    details = {
        "queue_predictions": queue_predictions,
        "event_sources_contribution": event_sources_contribution,
        "recommendations": recommendations,
        "simulation_note": "Queue predictions based on simplified model. Actual behavior depends on bus cycles, timer frequencies, and HMI interaction patterns."
    }

    return ValidationResult(success=True, errors=errors, warnings=warnings, details=details)


def main():
    args = parse_arguments()

    app_dir = Path(args.app_dir)
    event_flow_path = Path(args.event_flow_results)

    if not app_dir.exists():
        print(f"Error: Directory not found: {app_dir}", file=sys.stderr)
        sys.exit(1)

    if not event_flow_path.exists():
        print(f"Error: Event flow results not found: {event_flow_path}", file=sys.stderr)
        sys.exit(1)

    print(f"Predicting queue depths for: {app_dir}", file=sys.stderr)
    print(f"Scenario: {args.scenario}", file=sys.stderr)

    result = predict_queue_depth(app_dir, event_flow_path, args.scenario, args.resource)

    json_output = result.to_json()

    if args.output:
        with open(args.output, "w") as f:
            f.write(json_output)
        print(f"Results written to: {args.output}", file=sys.stderr)
    else:
        print(json_output)

    print(f"Analysis complete. Exit code: {result.exit_code}", file=sys.stderr)
    sys.exit(result.exit_code)


if __name__ == "__main__":
    main()
